-- vim:tw=0:ts=2:sw=2:et:norl:nospell:ft=lua
-- Author: Landon Bouma <https://tallybark.com/>
-- Project: https://github.com/DepoXy/macOS-Hammyspoony#ðŸ¥„
-- License: MIT

--- === AppTapAttach ===
---
--- Download: [https://github.com/DepoXy/macOS-Hammyspoony/raw/release/Spoons/AppTapAttach.spoon.zip](https://github.com/DepoXy/macOS-Hammyspoony/raw/release/Spoons/AppTapAttach.spoon.zip)

local obj = {}
obj.__index = obj

--- Metadata
obj.name = "AppTapAttach"
obj.version = "1.0.0"
obj.author = "Landon Bouma <https://tallybark.com/>"
obj.homepage = "https://github.com/DepoXy/macOS-Hammyspoony#ðŸ¥„"
obj.license = "MIT - https://opensource.org/licenses/MIT"

--- AppTapAttach.logger
--- Variable
--- - Logger object used within the Spoon. Can be accessed to set
---   the default log level for the messages coming from the Spoon.
obj.logger = hs.logger.new('AppTapAttach')

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

obj.trace = false
-- USAGE: Enable obj.trace for popup messaging.
--
--   obj.trace = true
--- Log trace messages to the Hammerspoon Console.
--- - Hints and whatnot:
---   - Callers can use hs.inspect() to convert tables and more
---     complex objects to text.
---   - We use print and not the logger b/c the logger adds a
---     lot of indentation.
---     - To see for yourself, try, e.g.:
---         obj.logger.setLogLevel("debug")
---         obj.logger.d("I'm indented oh so much!")
---       Then in Console you'll see:
---         2024-10-23 18:41:05:          AppTapAtta:     I'm indented oh so much!
---       (There might be a way to adjust this, but author hasn't checked.)
function obj:debug(msg, force)
  if (self.trace or force) then
    print(msg)
  end
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

obj.appEventtaps = {}

function obj:registerApptap(appName, getEventtap)
  obj.appEventtaps[appName] = getEventtap()
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

-- KLUGE: When the user switches applications, Hammerspoon will
-- first signal *activated*, then it'll signal *deactivated*.
--
-- - But if we start() the eventtap when *activated*, sometimes
--   replacement events generated by the eventtap go to the app
--   that's being *deactivated*.
--
-- - So we wait to call start() until the old app is *deactivated*.
--
-- - I don't quite know what's up, if there's a race condition, or
--   what, and I haven't looked at Hammerspoon sources, nor have I
--   searched for known issues or anything. Fortunately this
--   approach seems to work, so we'll just go with it.

obj.activeEventtap = nil

obj.pendingEventtap = nil

-- Just being nosy: Use a timer to alert if a *deactivated* event
-- does not always almost immediately follow an *activated* event.
obj.activateDeactiveTimer = nil

-- There's nothing too scientific about this value... it's more emperical.
obj.timerDelaySecs = 0.2

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

-- REFER: Posisible event types:
--   0 â€” hs.application.watcher.launching
--   1 â€” hs.application.watcher.launched
--   2 â€” hs.application.watcher.terminated
--   3 â€” hs.application.watcher.hidden
--   4 â€” hs.application.watcher.unhidden
--   5 â€” hs.application.watcher.activated
--   6 â€” hs.application.watcher.deactivated

function obj:appWatcherWatch(appName, eventType, theApp)
  -- print("appName: " .. appName .. " / eventType: " .. eventType)

  if eventType == hs.application.watcher.deactivated then
    self:stopTimer()

    if obj.activeEventtap then
      obj.activeEventtap:stop()
      obj.activeEventtap = nil
    end

    if obj.pendingEventtap then
      obj.activeEventtap = obj.pendingEventtap
      obj.pendingEventtap = nil
      obj.activeEventtap:start()
    end
  elseif eventType == hs.application.watcher.activated then
    obj.pendingEventtap = obj.appEventtaps[appName]

    self:stopTimer()

    obj.activateDeactiveTimer = hs.timer.doAfter(
      obj.timerDelaySecs,
      function()
        self:alertIfDeactivatedEventNotReceivedSoon(appName)
      end
    )
  end
end

function obj:stopTimer()
  if obj.activateDeactiveTimer then
    obj.activateDeactiveTimer:stop()
    obj.activateDeactiveTimer = nil
  end
end

function obj:alertIfDeactivatedEventNotReceivedSoon(appName)
  -- This is an unexpected path.

  local timeoutSecs = 5  -- Defaults 2 secs.

  hs.alert.show(
    "ALERT: No *deactivated* event followed *activate*"
      .. " / App: " .. appName
      .. " / Delay: " .. self.timerDelaySecs .. " mins.",
    timeoutSecs
  )
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

--- AppTapAttach:start()
--- Method
--- Starts the Spoon.
---
--- Parameters:
---  * (none)
function obj:start()
  self.appWatcher = hs.application.watcher.new(
    function(appName, eventType, theApp)
      self:appWatcherWatch(appName, eventType, theApp)
    end
  )

  self.appWatcher:start()
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

return obj

