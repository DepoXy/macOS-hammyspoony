-- vim:tw=0:ts=2:sw=2:et:norl:nospell:ft=lua
-- Author: Landon Bouma <https://tallybark.com/>
-- Project: https://github.com/DepoXy/macOS-Hammyspoony#ðŸ¥„
-- License: MIT

--- === AppTapAttach ===
---
--- Download: [https://github.com/DepoXy/macOS-Hammyspoony/raw/release/Spoons/AppTapAttach.spoon.zip](https://github.com/DepoXy/macOS-Hammyspoony/raw/release/Spoons/AppTapAttach.spoon.zip)

local obj = {}
obj.__index = obj

--- Metadata
obj.name = "AppTapAttach"
obj.version = "1.0.0"
obj.author = "Landon Bouma <https://tallybark.com/>"
obj.homepage = "https://github.com/DepoXy/macOS-Hammyspoony#ðŸ¥„"
obj.license = "MIT - https://opensource.org/licenses/MIT"

--- AppTapAttach.logger
--- Variable
--- - Logger object used within the Spoon. Can be accessed to set
---   the default log level for the messages coming from the Spoon.
obj.logger = hs.logger.new('AppTapAttach')

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

obj.trace = false
-- USAGE: Enable obj.trace for popup messaging.
--
--   obj.trace = true
--- Log trace messages to the Hammerspoon Console.
--- - Hints and whatnot:
---   - Callers can use hs.inspect() to convert tables and more
---     complex objects to text.
---   - We use print and not the logger b/c the logger adds a
---     lot of indentation.
---     - To see for yourself, try, e.g.:
---         obj.logger.setLogLevel("debug")
---         obj.logger.d("I'm indented oh so much!")
---       Then in Console you'll see:
---         2024-10-23 18:41:05:          AppTapAtta:     I'm indented oh so much!
---       (There might be a way to adjust this, but author hasn't checked.)
function obj:debug(msg, force)
  if (self.trace or force) then
    print(msg)
  end
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

obj.appEventtaps = {}

function obj:registerApptap(appName, getEventtap)
  self.appEventtaps[appName] = getEventtap()
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

--- KLUGE: When the user switches applications, Hammerspoon will sometimes
--- first signal *activated*, then it'll signal *deactivated*.
---
--- - But sometimes it signals deactivated first, then activated.
---
--- - In the first case, if we start() the eventtap when *activated*,
---   sometimes replacement events generated by the eventtap go to the
---   app that's being *deactivated*.
---
--- - So we wait to call start() until the old app is *deactivated*
---   in the first case, or after the new app is *activated* in the
---   second case.
---
--- - (I don't quite know what's up, if there's a race condition, or
---   what, and I haven't looked at Hammerspoon sources, nor have I
---   searched for known issues or anything. Fortunately this
---   approach seems to work, so we'll just go with it.)

--- EXTRA: The plot thickens!
---
--- - When you run Meld, the event sequence is normal.
---
--- - But when you Quit Meld, it's very special:
---
---   - hs.application.watcher signals *deactivated*, but:
---
---     - appName is nil
---     - print(hs.inspect(theApp)) shows "(null)" instead of a name
---     - theApp:title() is nil
---     - theApp:bundleID() is nil
---
---   - Next you'll see 'loginwindow' activated
---
---   - Then 'python3' is terminated
---
---   - Then the next app is *activated*
---
---   - And finally 'loginwindow' is *deactivated*
---
--- - If you enabled trace (before this kluge), you might have seen, e.g.,
---
---     2024-10-24 18:45:26: APPTAP: deactivated / 1st event / (unnamed app?)
---     2024-10-24 18:45:26: APPTAP: activated   / 2nd event / loginwindow
---     2024-10-24 18:45:26: APPTAP: terminated  / dont care / python3
---     2024-10-24 18:45:26: APPTAP: activated   / 1st event / MacVim
---     2024-10-24 18:45:26: APPTAP: deactivated / 2nd event / loginwindow
---
--- - Also, you might see the *activated* event first for the named app,
---   then the nameless app deactivated and terminated, without either
---   'loginwindow' event. I know, right.
---
--- - Note that switching from Meld to another app (and not quitting) is
---   normal (albeit the appName is 'python3').
---
--- As such, if *deactivated* doesn't have a name, we'll wait for a third
--- event, *terminated*.
---
--- - We'll also throw an alert if the *terminated* app is *not* 'python3',
---   out of curiosity if this issue afflicts any other app.

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

--- The eventtap for the foreground app, if your Hammerspoon config has
--- registered an eventtap for the app.
obj.activeEventtap = nil

--- When switching apps, wait for both events (activated and deactivated;
--- or activated and terminated, as discussed above), before changing taps.
obj.pendingEventtap = nil

--- For confidence checking this Spoon's state machine.
obj.previousEventType = nil

--- To handle the special Meld/python3 state transition (see "EXTRA", above).
obj.namelessAppWasDeactivated = false

-- Just being nosy: Use a timer to alert if the *deactivated* event
-- and the *activated* event are not within timerDelaysSecs secs. of
-- one another.
obj.activateDeactiveTimer = nil

-- There's nothing scientific about this value. Call it emperical.
obj.timerDelaySecs = 0.2

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

-- REFER: Possible event types:
--   0 â€” hs.application.watcher.launching
--   1 â€” hs.application.watcher.launched
--   2 â€” hs.application.watcher.terminated
--   3 â€” hs.application.watcher.hidden
--   4 â€” hs.application.watcher.unhidden
--   5 â€” hs.application.watcher.activated
--   6 â€” hs.application.watcher.deactivated

obj.eventTypeName = {
  [hs.application.watcher.launching]    = "launching  ",
  [hs.application.watcher.launched]     = "launched   ",
  [hs.application.watcher.terminated]   = "terminated ",
  [hs.application.watcher.hidden]       = "hidden     ",
  [hs.application.watcher.unhidden]     = "unhidden   ",
  [hs.application.watcher.activated]    = "activated  ",
  [hs.application.watcher.deactivated]  = "deactivated"
}

obj.appActivatedOrDeactivated = {
  [hs.application.watcher.activated] = true,
  [hs.application.watcher.deactivated] = true,
}

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

function obj:appWatcherWatch(appName, eventType, _theApp)
  local appNameStr = appName or "(nameless!)"

  --- See "EXTRA" comment above re: Meld/python3 behavior.
  if not appName and eventType == hs.application.watcher.deactivated then
    self:debug("APPTAP: " .. self.eventTypeName[eventType] .. " / --- event / (nameless!)")

    -- This is a *deactivated* event for an unnamed app.
    -- - Wait for its *terminated* event.
    self.namelessAppWasDeactivated = true

    return
  end

  -- Guard clause aka short circuit.
  if not (self.namelessAppWasDeactivated and eventType == hs.application.watcher.terminated)
    and not self.appActivatedOrDeactivated[eventType]
  then
    self:debug("APPTAP: " .. self.eventTypeName[eventType] .. " / dont care / " .. appNameStr)

    return
  end

  self:stopTimer()

  if not self.previousEventType then
    self:beginStateTransition(appName, eventType, appNameStr)
  else
    self:completeStateTransition(eventType, appNameStr)
  end
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

function obj:beginStateTransition(appName, eventType, appNameStr)
  self:debug("APPTAP: " .. self.eventTypeName[eventType] .. " / 1st event / " .. appNameStr)

  -- More often than not, the previous event is activated, but sometimes
  -- it's the deactivated event. Though in either case, we don't care.
  self.previousEventType = eventType

  -- Start the eventtap on the subsequent activated/deactivated.
  if appName then
    self.pendingEventtap = self.appEventtaps[appName]
  end

  -- But don't wait for another event to happen, in case it doesn't
  -- (though author has never seen it not happen).
  self.activateDeactiveTimer = hs.timer.doAfter(
    self.timerDelaySecs,
    function()
      local eventType = nil

      self:changeEventtapsAndAlertIfFollowUpEventNotReceivedSoon(eventType, appNameStr)
    end
  )
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

function obj:completeStateTransition(eventType, appNameStr)
  local eventTypeName = self.eventTypeName[eventType] or "timed out!!"

  self:debug("APPTAP: " .. eventTypeName .. " / 2nd event / " .. appNameStr)

  self.previousEventType = nil

  self:resetNamelessAppWasDeactivated(appNameStr)

  self:changeEventtaps()
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

function obj:changeEventtaps()
  if self.activeEventtap then
    self.activeEventtap:stop()
    self.activeEventtap = nil
  end

  if self.pendingEventtap then
    self.activeEventtap = self.pendingEventtap
    self.pendingEventtap = nil
    self.activeEventtap:start()
  end
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

-- SAVVY/2024-11-01: Some apps are reported without their name when
-- deactivated, e.g., here's changing from to Chrome from MacVim,
-- and note that these events all had the same timestamp (i.e.,
-- they were all received sequentially after author AltTabbed),
-- also I'm not sure why Chrome was activated, then deactived,
-- then activated again!:
--
--   APPTAP: launching   / dont care / Google Chrome
--   APPTAP: activated   / 1st event / Google Chrome
--   APPTAP: deactivated / 2nd event / MacVim
--   APPTAP: launched    / dont care / Google Chrome
--
--   APPTAP: activated   / 1st event / MacVim
--   APPTAP: deactivated / --- event / (nameless!)
--   APPTAP: terminated  / 2nd event / Google Chrome
--
--   APPTAP: activated   / 1st event / Google Chrome
--   APPTAP: deactivated / 2nd event / MacVim
--
-- Author has also observed similar event sequence opening Chrome window
-- from terminal, e.g.,
--
--   APPTAP: activated   / 1st event / Google Chrome
--   APPTAP: deactivated / 2nd event / Alacritty
--   APPTAP: launching   / dont care / Google Chrome
--   
--   APPTAP: activated   / 1st event / Google Chrome
--   APPTAP: deactivated / 2nd event / Google Chrome
--   APPTAP: launched    / dont care / Google Chrome
--   
--   APPTAP: activated   / 1st event / Google Chrome
--   APPTAP: deactivated / --- event / (nameless!)
--   APPTAP: terminated  / 2nd event / Google Chrome

obj.namelessDeactivatedOkay = {
  ["python3"] = true,
  ["Google Chrome"] = true,
}

function obj:resetNamelessAppWasDeactivated(appNameStr)
  if not self.namelessAppWasDeactivated then

    return
  end

  self.namelessAppWasDeactivated = false

  if not self.namelessDeactivatedOkay[appNameStr] then
    local alertMsg = "APPTAP: GAFFE: Unexpected nameless app deactivated: \"" .. appNameStr .. "\""

    self:debug(alertMsg)

    hs.alert.show(alertMsg)
  end
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

function obj:stopTimer()
  if self.activateDeactiveTimer then
    self.activateDeactiveTimer:stop()
    self.activateDeactiveTimer = nil
  end
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

function obj:changeEventtapsAndAlertIfFollowUpEventNotReceivedSoon(eventType, appNameStr)
  -- This is an unexpected path.
  local previousEventName = string.gsub(
    self.eventTypeName[self.previousEventType] or "(no prev. event)",
    "%s+$",
    ""
  )

  local message = ("APPTAP: ALERT: Got "
      .. previousEventName
      .. " but not its follow-up"
      .. " / App: " .. appNameStr
      .. " / Delay: " .. self.timerDelaySecs .. " mins."
  )

  self:debug(message)

  local timeoutSecs = 5  -- Defaults 2 secs.

  hs.alert.show(message, timeoutSecs)

  -- Seems like we should do this anyway... or maybe not,
  -- since this path never happens to the author? (Though
  -- if that's the answer, maybe we should at least stop
  -- the old eventtap, but not start the new one?)
  obj:completeStateTransition(eventType, appNameStr)
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

--- AppTapAttach:start()
--- Method
--- Starts the Spoon.
---
--- Parameters:
---  * (none)
function obj:start()
  self.appWatcher = hs.application.watcher.new(
    function(appName, eventType, theApp)
      self:appWatcherWatch(appName, eventType, theApp)
    end
  )

  self.appWatcher:start()
end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

return obj

